Logging

Levels: E, W, M, 1 2 3 4 5
	Error, Warning, Message (Info)
	plus 5 debugging levels

Output:
	stderr
	curses
	queued
	file

Attrs:
	timestamp
	file
	line
	function
	level
	format
	args...

error(fmt, args...)
	message()
	warning()
	debug()
all #defines to log_dispatcher (a function variable)
log_dispatcher -> dispatcher_curses()

dispatcher_curses()
	error -> file, screen
	message -> file, screen
	debug -> file

dispatcher_file() if enabled
	write to file
	optionally flush after every
		error
		n messages
		n seconds

where does the timestamp originate?
where does the debug level filtering occur?
	probably in dispatcher_file()

multiple dispatchers
	if logging is disabled, then keep a small ring of messages

dispatch_curses -> screen
dispatch_file -> disk
dispatch_queue -> memory
dispatch_stderr -> stderr

all dispatch functions to take all params
flush_queue(dispatch_function)

rename .neomuttdebug -> .neomutt_log?

easier to display backlog if messages are *always* written to disk
neomutt -d0 (or absent) => only write M, W, E to disk

:messages show file verbatim
could colour code according to error/info colours
	need to save in a parsable way, e.g. <E>, <3>

macros pass 0 for time
	disp_queue saves now()
	flushq passes saved time

debug macro passes file, line, func
	others pass NULL

M,W,E and D macros pass level, fmt, args

if no log file, create tmp, populate from ring and display in pager

migrate debugging -> logging
LogLevel 0..5
LogFile  file (template) or % expandos
LogKeep  5?

once started we can't know the log's filename
(could be renamed by other instances)

expandos for template
	%p pid
	%t time (HH:MM) :SS?
	%d date (YYYY-MM-DD)
expand other stuff too?
	$config vars?
	$ENV vars?
variable is only expanded and checked when set
	=> no new logfile at midnight

what's preventing LOTS of logfiles?

if there are zero expandos (or variables)
	then rotate up to 5 files
otherwise
	!exists - create
	exists - append
accumulate lots of files, up to user to clear them

default to ~/.neomutt/logs/log
default location means we could syntax highlight
	error,warning,message,debug (grey for levels 3,4,5)

variable/config ownership
lib
	DebugFile, set_file()
	DebugLevel, set_level()
	FILE*
	actual filename/level aren't needed
mutt
	Initial file
	Initial level
	for reset

Logging bug
	Leave mutt running, then
	start/close mutt 5 times
	log file of running mutt has been deleted

use file locking on logs to prevent overwriting
	or premature deletion

option in :messages page to save the text

------------------------------------------------------------

main()
	logq
	getopt
	if 'v'
		flush(stderr)
		exit
	read_config
	if 'D'
		flush(stderr)
		exit
	
	** DebugFile
	** DebugLevel

	start_debug(file,level)
	flush(curses)
	main_loop()
	stop_debug()
	exit

------------------------------------------------------------

start_debug(file,level)
	expand_file(file)
	rotate_files()
	log_level(level)
	log_open(file0)

------------------------------------------------------------

log_level(level)
	static level = 9
	if (level changes) & (level != 9)
		set level
		debug("logging at level %d")

------------------------------------------------------------

log_open(file)
	static file = ""
	if file changed
	empty -> empty
		do nothing
	empty -> name
		create file / append
		log "starting"
			is this my job?
			don't know the version
	name -> empty
		log "closing"
		close file
	name -> name (same)
		do nothing
	name -> name (diff)
		log "closing"
		close old
		open new
		log "opening"

------------------------------------------------------------

stop_debug()
	log_stderr
	log_close

------------------------------------------------------------

log_close
	log "closing"
	close file
	file=""

------------------------------------------------------------

FILE debug/error()
	if (lev <= dlev) && (file open)
		write to file

------------------------------------------------------------

CURSES debug/error()
	FILE_debug() duplicate
	normal screen stuff

------------------------------------------------------------

STDERR debug/error()
	if (lev <= dlev) && (file open)
		write to stderr

------------------------------------------------------------

QUEUE debug/error()
	save to Q

------------------------------------------------------------

