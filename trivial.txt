simplify cppcheck example
	cppcheck --enable=all --language=c --std=c99 -i autosetup --platform=unspecified -D_POSIX_PATH_MAX=4096 -DPATH_MAX=2048 -I/usr/include -I/usr/include/mit-krb5 -I. --output-file=cppcheck.xml --xml --xml-version=2 <path to neomutt source code directory>
	cppcheck --enable=all --language=c --std=c99 -i autosetup -D_POSIX_PATH_MAX=4096 -DPATH_MAX=2048  -I. --output-file=c1  .
use --check-config to list missing header files
	cppcheck --verbose --check-config --enable=all --language=c --std=c99 -i autosetup -i test -DPATH_MAX=2048 -D__x86_64__ -I. -I/usr/include -I/usr/lib/gcc/x86_64-redhat-linux/8/include -I/usr/include/qdbm --output-file=c1 .
	ignore doc dir too

fix !USE_NNTP build
	check !USE_SIDEBAR build

free functions to take (**ptr)
then deref to Type *t = *ptr;

add printf format checkers to mutt_message, mutt_debug, etc

test int against 0
	what about ALL int members?

demote to warnings
mutt_error(_("Warning: XXX"));

simplify all our:  if (X) free(X)
add doxy param doc: (NULL safe) ?

if (!(a && b))
if (!(a || b))
ag 'if \(!\(.*(&&|\|\|).*\)\)'

ag '\(!\((.*) && (.*)\)\)'
ag '\(!\((.*) \|\| (.*)\)\)'

eliminate enum AccountType?
use enum MailboxType
	what about smtp?
	add entry?

split up multiple assignments
	grep " = [^,;]* = "
	grep " = [^,;]* [!=]= "

conditional constants - reduce to a comment
	Hmm... non-functional enum entries might cause problems
	MENU_KEY_SELECT_PGP
	MENU_MIX
	MT_COLOR_DIVIDER
	MUTT_PAT_NEWSGROUPS
	MUTT_OPEN_HOOK
	REDRAW_SIDEBAR

body_copy() : move foreach param -> param_dup()

check all src against vim folding

pager
	replace CHECK_* macros with function
	bool pre_requisite(flag|flag, quiet);
	if (!pre_requisite())
		break
	need interface for index/pager operations?
	what are possible outcomes?
	break (continue loop)
	exit (function)
	fallthrough? NO refactor to avoid

replace "for (int" -> size_t in libmutt
	177 occurrences

browser.c has a lot of
	struct Email *tmp;
	tmp's a bad name for a variable
	scratch is too

move all
	if (!param)
	to start of function
	return early
	ag "^ +if \(.*\n +return"
	2540 functions
	start with libmutt?

decrypt_part - Explain r_is_signed better
	returns -1, 0, 1, 2

are these identical? YES
	static char crypt_flags(KeyFlags flags)
	static char pgp_flags(KeyFlags flags)

convert to enum?
	struct ConnAccount.type
		unsigned char type;     ///< Connection type, e.g. #MUTT_ACCT_TYPE_IMAP

config system
	can it return warnings?
	yes, but it doesn't

init.c
	getsid() is POSIX2001
	no need for #ifdef?
	exists in cygwin

variables, urgh! sendlib.c
	mutt_lookup_mime_type() int szf, sze, cur_sze;

deglobalise
	EnvList in mutt/envlist.c
	C_HiddenTags in driver_tags_add()

string fn to pretty print \t, \r, \n for tests
	handle NULL, quote string

mutt_parse_rc_line(char *line, struct Buffer *token, struct Buffer *err)
	'token' is a tmp buffer -> 'tmp' (or 'scratch')
	or eliminate it with the BufferPool

wrong name, should be _free()
	void mutt_addrlist_clear(struct AddressList *al)
	...
	mutt_addr_free(&a);
	hmm... but it doesn't free the actual AddressList

This doesn't seem to be documented in neomutt's manual either
I wonder if we could kill this unexpected behaviour
  /* This is an undocumented feature of ELM pointed out to me by Felix von
   * Leitner <leitner@prz.fu-berlin.de> */
  if (mutt_str_strcmp(mutt_b2s(buf), ".") == 0)
    mutt_buffer_strcpy(buf, LastSaveFolder);
  else
    mutt_str_strfcpy(LastSaveFolder, mutt_b2s(buf), sizeof(LastSaveFolder));

SEND_NO_FREE_HEADER refers to an Email, SEND_NO_FREE_EMAIL?

should be _free() -> need _new() too
	void mutt_bcache_close(struct BodyCache **bcache)

flags typedef?
	/* force flags passed to mutt_mailbox_check() */
	#define MUTT_MAILBOX_CHECK_FORCE       (1 << 0)
	#define MUTT_MAILBOX_CHECK_FORCE_STATS (1 << 1)

flagify
	#define MUTT_UNBIND  1<<0
	#define MUTT_UNMACRO 1<<1

mutt_mailbox.c rename var?
	struct stat contex_sb;

rename to 'index'?
	hdrline.c
	struct HdrFormatInfo

find out meaning of "ci_" prefix, or drop it (curses interface?)
	CI_is_return
	ci_bounce_message
		bounce_message
		ci_bounce_message
		mutt_attach_bounce
		mutt_bounce_message
	ci_first_message
	ci_next_undeleted
	ci_previous_undeleted
	ci_send_message
		mix_send_message
		mutt_resend_message
		send_message

eliminate complicated macros (multiline, conditionals, many callers)
refactor complicated or oft-used macros
	index.c:144:1:       CAN_COLLAPSE     5
	pager.c:285:1:       CHECK_ACL        28
	pager.c:277:1:       CHECK_ATTACH     42
	recvattach.c:100:1:  CHECK_ATTACH     19
	compose.c:118:1:     CHECK_COUNT      32
	pager.c:261:1:       CHECK_MODE       34
	pager.c:269:1:       CHECK_READONLY
	recvattach.c:82:1:   CHECK_READONLY
	pattern.c:93:1:      CTX_MSGNO        5
	email/mime.h:85:1:   ENCODING         7
	pager.c:254:1:       IsAttach         10
	pager.c:257:1:       IsEmail          42
	pager.c:255:1:       IsMsgAttach      22
	email/mime.h:77:1:   is_multipart     8
	mutt/buffer.h:43:1:  MoreArgs         78
	mutt/regex3.h:52:1:  REG_COMP         18
	mutt/string2.h:47:1: SKIPWS           51
	state.h:56:1:        state_putc       30
	state.h:55:1:        state_puts       98
	mutt/string2.h:60:1: terminate_buffer 9
	mutt/string2.h:51:1: terminate_string 5
	email/mime.h:83:1:   TYPE             35

these 2 typedefs don't match the pattern for function typedefs
	header_cache_t    hcache/hcache.h   /^typedef struct EmailCache header_cache_t;$/;"
	keycode_t         keymap.h          /^typedef short keycode_t;$/;"

main.c
	text outside of else, search for others (over 60 comments before else)
	/* If editing the infile, keep it around afterwards so
	 * it doesn't get unlinked, and we can rebuild the draft_file */
	else

neomuttlog.vim
	offer to vim ml

needs typedef
needs NO_FLAGS
#define U_PATH          (1 << 1)

why are enum SortType numbered?
	SORT_ALPHA    =  3, ///< Required by makedoc.c
	SORT_SUBJECT  =  3, ///< Sort by the email's subject
	do we need SORT_MAX
	do we need ANY X_MAX enum values?

should use a Buffer
	void mutt_default_save(char *path, size_t pathlen, struct Email *e)
	problem: it leads to format functions that take buf, buflen

variable i used for rc and `for` loops
	static int mbox_mbox_sync(struct Mailbox *m, int *index_hint)

shellcheck hcachever.sh
	test output against various releases

move to email/body? (and rename)
	struct Body *mutt_make_multipart(struct Body *b)
	struct Body *mutt_remove_multipart(struct Body *b)
	create email/multipart.c ?

base32 doesn't belong in mutt/random.c
	maybe in mutt/string.c

config
	have macro -- VALID_PTR() for native retvals?

not closed on exit
	static FILE *fp_random;

flip to match M.verbose
	#define MUTT_QUIET         (1 << 3) ///< Do not print any messages

rename Email.content to Email.body

more @extends keywords
	look for all Xdata members (and Xdata_free) and the structs that are attached

change to **ptr, look for others
	static void menu_free(struct Menu **menu)
	address_free	config/address.c	/^void address_free(struct Address **addr)$/;"	f	typeref:typename:void
	aliaslist_free	alias/alias.c	/^void aliaslist_free(struct AliasList *al)$/;"	f	typeref:typename:void
	buffer_free	mutt/pool.c	/^static void buffer_free(struct Buffer **p)$/;"	f	typeref:typename:void	file:
	compress_info_free	compmbox/compress.c	/^static void compress_info_free(struct Mailbox *m)$/;"	f	typeref:typename:void	file:
	crypt_key_free	ncrypt/crypt_gpgme.c	/^static void crypt_key_free(struct CryptKeyInfo **keylist)$/;"	f	typeref:typename:void	file:
	crypto_module_free	ncrypt/crypt_mod.c	/^void crypto_module_free(void)$/;"	f	typeref:typename:void
	defs_free	gui/color.c	/^static void defs_free(struct Colors *c)$/;"	f	typeref:typename:void	file:
	driver_tags_free	email/tags.c	/^void driver_tags_free(struct TagList *list)$/;"	f	typeref:typename:void
	key_free	ncrypt/pgplib.c	/^static void key_free(struct PgpKeyInfo **kpp)$/;"	f	typeref:typename:void	file:
	maildir_free	maildir/shared.c	/^static void maildir_free(struct Maildir **md)$/;"	f	typeref:typename:void	file:
	mbtable_free	config/mbtable.c	/^void mbtable_free(struct MbTable **table)$/;"	f	typeref:typename:void
	menu_free	autocrypt/dlgautocrypt.c	/^static void menu_free(struct Menu **menu)$/;"	f	typeref:typename:void	file:
	mhs_sequences_free	maildir/mh.c	/^void mhs_sequences_free(struct MhSequences *mhs)$/;"	f	typeref:typename:void
	mix_type2_list_free	remailer.c	/^static void mix_type2_list_free(struct Remailer ***ttlp)$/;"	f	typeref:typename:void	file:
	monitor_check_free	monitor.c	/^static void monitor_check_free(void)$/;"	f	typeref:typename:void	file:
	monitor_info_free	monitor.c	/^static void monitor_info_free(struct MonitorInfo *info)$/;"	f	typeref:typename:void	file:
	mutt_actx_entries_free	email/attach.c	/^void mutt_actx_entries_free(struct AttachCtx *actx)$/;"	f	typeref:typename:void
	mutt_autocrypthdr_free	email/envelope.c	/^void mutt_autocrypthdr_free(struct AutocryptHeader **p)$/;"	f	typeref:typename:void
	mutt_buffer_pool_free	mutt/pool.c	/^void mutt_buffer_pool_free(void)$/;"	f	typeref:typename:void
	mutt_color_free	gui/color.c	/^void mutt_color_free(struct Colors *c, uint32_t fg, uint32_t bg)$/;"	f	typeref:typename:void
	mutt_envlist_free	mutt/envlist.c	/^void mutt_envlist_free(void)$/;"	f	typeref:typename:void
	mutt_grouplist_free	address/group.c	/^void mutt_grouplist_free(void)$/;"	f	typeref:typename:void
	mutt_hash_set_destructor	mutt/hash.c	/^void mutt_hash_set_destructor(struct HashTable *table, hash_hdata_free_t fn, intptr_t fn_data)$/;"	f	typeref:typename:void
	mutt_hcache_free_raw	hcache/hcache.c	/^void mutt_hcache_free_raw(struct HeaderCache *hc, void **data)$/;"	f	typeref:typename:void
	mutt_hist_free	history/history.c	/^void mutt_hist_free(void)$/;"	f	typeref:typename:void
	mutt_keys_free	keymap.c	/^void mutt_keys_free(void)$/;"	f	typeref:typename:void
	mutt_list_free	mutt/list.c	/^void mutt_list_free(struct ListHead *h)$/;"	f	typeref:typename:void
	mutt_list_free_type	mutt/list.c	/^void mutt_list_free_type(struct ListHead *h, list_free_t fn)$/;"	f	typeref:typename:void
	mutt_mem_free	mutt/memory.c	/^void mutt_mem_free(void *ptr)$/;"	f	typeref:typename:void
	mutt_opts_free	init.c	/^void mutt_opts_free(void)$/;"	f	typeref:typename:void
	mutt_param_free	email/parameter.c	/^void mutt_param_free(struct ParameterList *pl)$/;"	f	typeref:typename:void
	mutt_param_free_one	email/parameter.c	/^void mutt_param_free_one(struct Parameter **p)$/;"	f	typeref:typename:void
	mutt_pattern_free	pattern/compile.c	/^void mutt_pattern_free(struct PatternList **pat)$/;"	f	typeref:typename:void
	mutt_prex_free	mutt/prex.c	/^void mutt_prex_free(void)$/;"	f	typeref:typename:void
	mutt_regex_free	mutt/regex.c	/^void mutt_regex_free(struct Regex **r)$/;"	f	typeref:typename:void
	mutt_regexlist_free	mutt/regex.c	/^void mutt_regexlist_free(struct RegexList *rl)$/;"	f	typeref:typename:void
	mutt_replacelist_free	mutt/regex.c	/^void mutt_replacelist_free(struct ReplaceList *rl)$/;"	f	typeref:typename:void
	mutt_window_free_all	gui/mutt_window.c	/^void mutt_window_free_all(void)$/;"	f	typeref:typename:void
	mutt_winlist_free	gui/mutt_window.c	/^void mutt_winlist_free(struct MuttWindowList *head)$/;"	f	typeref:typename:void
	myvarlist_free	myvar.c	/^void myvarlist_free(struct MyVarList *list)$/;"	f	typeref:typename:void
	nm_db_free	notmuch/db.c	/^void nm_db_free(notmuch_database_t *db)$/;"	f	typeref:typename:void
	nntp_acache_free	nntp/newsrc.c	/^void nntp_acache_free(struct NntpMboxData *mdata)$/;"	f	typeref:typename:void
	nntp_hashelem_free	nntp/nntp.c	/^static void nntp_hashelem_free(int type, void *obj, intptr_t data)$/;"	f	typeref:typename:void	file:
	parameter_free	email/rfc2231.c	/^static void parameter_free(struct Rfc2231Parameter **p)$/;"	f	typeref:typename:void	file:
	pgp_key_free	ncrypt/pgplib.c	/^void pgp_key_free(struct PgpKeyInfo **kpp)$/;"	f	typeref:typename:void
	pgp_uid_free	ncrypt/pgplib.c	/^static void pgp_uid_free(struct PgpUid **upp)$/;"	f	typeref:typename:void	file:
	quotes_free	gui/color.c	/^static void quotes_free(struct Colors *c)$/;"	f	typeref:typename:void	file:
	recipient_set_free	ncrypt/crypt_gpgme.c	/^static void recipient_set_free(gpgme_key_t **p_rset)$/;"	f	typeref:typename:void	file:
	regex_free	config/regex.c	/^void regex_free(struct Regex **r)$/;"	f	typeref:typename:void
	slist_free	mutt/slist.c	/^void slist_free(struct Slist **list)$/;"	f	typeref:typename:void
	smime_key_free	ncrypt/smime.c	/^static void smime_key_free(struct SmimeKey **keylist)$/;"	f	typeref:typename:void	file:
	zstrm_free	conn/zstrm.c	/^static void zstrm_free(void *opaque, void *address)$/;"	f	typeref:typename:void	file:

missing comments
  { "select-entry",    OP_GENERIC_SELECT_ENTRY, "\n" },
  { "select-entry",    OP_GENERIC_SELECT_ENTRY, "\r" },

