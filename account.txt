Context - paths, counts
Header[] list -> Env, Body, etc
Incoming -> Buffy[] (paths, counts)
Buffy 1/mailbox
no concept of account
Incoming becomes Account list
Account: imap server, maildir, notmuch, nntp?
account list: imap1, imap2, notmuch
Account named
who owns the context?
where is the config attached?

Account1
	mailbox[] (nested?)
Account2
	mailboxes
Account3
	mailboxes

62 functions use the context
22 functions use incoming

Context
Connection
Account
Mailbox
ConfigSet

Each host needs private data

NeoMutt - Config/globals
	Account (default)
	Account (specific)
		imap, pop, maildir, notmuch, etc
		Mailboxes (ref counted)
			Emails (ref counted) (Header, env, body, etc)

Account data private
	mxops

Where do patterns, limits, tagging live?
	On context (a mailbox *view*?)

Who uses Context, when a Account/Mailbox would do?

Context is a *view* of a mailbox
	who owns the views?

Mailbox should own headers, etc
	(id|subj|label) hashes

View has thread, tree/sorting data
Who owns Accounts?
	global to start with
	AccIncoming

Account
	IMAP 1 server/port/user combo
	POP 1 server/port/user combo
	Maildir user configurable set of folders (mailboxes)
	NNTP 1 server/port/user combo
	Notmuch 1 notmuch database

data, free_cb() + some fields common to all, name
Where do unsubscribed folders live?
not all Account's mailboxes are visible (subscribed/in sidebar)
Acc needs inherited config info -> separate object?
Config/Account -> Local Config
unaccount - closes connection, mailboxes, etc

Auto Accounts - Imap, pop, notmuch, nntp
how does 'account' command fit in?
mailboxes -> current 'account' NO -> default, YES use it
none -> 1 Account  incoming underneath
full auto -> find_ac(folder) -> folder not enough
	need user, host, port
account-ish config have user -> imap_user, what if they set A:imap_user?
account/set folder spoolfile, postponed, trash, record
use status bar to show their values, NO, not dynamic
need changed-account notification (account-hook) -> redraw
examples in 4 languages to highlight folder names (1 CJK)

NeoMutt object
	Config
	Connections
	Context
		Threads
	AccountList
		Account
			MailboxList
				EmailList
					Env, Body...

Mailboxes M
ask MXAPI for type of M
search As for owner?
or use A from config (if compatible)
or create new A (uniq name)
Add M to A

How does A test for M's membership?
*same* type (magic), $folder [user,host,port]
	login_cmp()
or mx_cmp() -- let *it* canonicalise $folder and compare login

Compare needs canon mailbox: have $folder, mailbox
path_canon($folder, mailbox) -> canon_mailbox
	NO needs login
pretty_path(A, ...) what's needed?
URL syntax:
	account://NAME/rel-path
or
	mailbox://ANAME/rel-path
or canon
	imaps://user@host:port/rel-path
abbreviate to:
	a:// or m://

Account NAME
set folder, imap user (pass)
mailboxes

folder could be '/', or empty or full path
X_{user,pass,login} -> {user,pass,login}
config name clash?
NO folder needs to be full else don't know which type the mailbox is

API mx_check_empty(path) -> bool - local use only
	or just open it?
API has_new_mail(path) - need to identify it first

∀ mailboxes - find by path, is notmuch, realpath, complex
	test empty, insert, remove, free

A is typed if all children are the same type, e.g. Notmuch

change functions to take a MailboxList (rather than a mailbox)
	UI creates list of one (for single selections)
	or a multiple for tagged
	thus centrlising tagging logic
	MailboxList or HeaderList

Header*View* is_tagged, etc can't be List
	needs to be sortable
	can we have *both*, Incoming and AccountList?
	How do I move Context inners to Mailbox?

Mailbox set, find -> obj + type
set trash = "x://path"
later resolve_mailbox($trash) -> lookup
find it, update ptr.  !found -> get type
Account -> Mailbox -> Email
path, (type?), Mailbox?

allow utf-8 account names?
	only forbid ':' scope separator
	store as punycode?
	store as b64-encoded?
	something to allow all characters

ac_get_str(A, IC_X) -> ptr to var
	what if someone changes it? crash!

have a magic Account for temporary mbox files?

when opening a folder from, what path string do we get?
	sidebar - full path
	browser - full path
	typed in - relative to current folder/account

C)ontext, A)ccount, M)ailbox, H)eader, T)hread

Move headers from C to M
	H array, ref-counted

C has Thread hashes (belong on M?)

Move C hdrs, but not v2r (that's *our* array)

First separate H from T?
	could we leave T in H to start?

Does the H need to know:
	a) it's in a T?
	b) which T it's in
	H Header no, UH User-Header YES

Does the UI wnat to work with UH which has T info, tagging, etc?

HV HeaderView
	C has HV[]
T is tree of HV (ptrs to H)
C needs to become MV (MailboxView)

Index, Pager wrt H
Who owns C, pass it down through functions

29 uses of Incoming
734 uses (82 functions using) Context

N -> AL -> NL -> EL (HEB, etc)

V)iew
L)ist

Index (MV), Pager (EV), Sidebar(AV) - viewers

MV has M, EL (subset of M's)
EL node (tagged, deleted, etc), sort
EV has E, cahced text, colour info, view info
AV has AL (subset of N's) current A, M, sort info

base object for all has
	type
	refcount
	bool deleted (or similar)

sidebar
	AV - $acc_view, $sb_sort
	MV new-only, sort
	SB maintains: highlight/selection, window view

index
	MV one mailbox
	EV tagging, limit, sort, threading, current selection

Pager
	EV one email - local (per email settings)

Index fmt uses I's MV, EV?
Status bar uses I's MV info
Pager bar needs I's MV info for (email x of y)
	needs P's EV for subject, %age through email

mx_open() open and attach to (create if nec.) account
	NO already done
config -> account tree
open M, not ready, open A, open M
Open A notify, e.g. sidebar A(red) -> A(green)
Open M notify sb -> active M, Index clears
Get Es notify -> Index populates
	that's probably the index doing the work
Open E notify whom?

Can the status bar *not* exist - just run on notifications. NO!

A name
mailboxes x y z
set folder
set imap_user
set imap_pass
set spoolfile
set postponed
set trash
set imap_list_subscribed

need default A type unknown, unnamed

'account' named A, type unknown [CREATE-A] (to AL)
set folder -> local config (imap_user, pass, etc, too)
mailboxes x y z relative to local $folder [ADD-M] to (to A)
	=> type -> IMAP
if mailboxes other:// type add to default (one type / A)

M has ptr to A (needed for cfg, etc)
chdir to PATH -> as As for a match
	A.match against local $folder NO match -> fail
	search through existing M [ABCDE] subscribed
or
	create new M [G]
or
	browser open / sidebar open

M: last update: never
A: state closed

mx_mbox_open(M) -> imap_acc_open (M -> A)
imap_acc_open(A) -> socket, conn stuff
	get mailboxes? if so, update statuses of Ms
	M: UNPOP, POPULATED, NOT_EXIST - notify
open(M) -> imap_mbox_open(M)
	if (!exist) error
	if (POPULATED) done
UNPOPULATED
	get email IDs; notify (may be in hcache)

"open" is too wide: need
	list new
	list all
	get headers (list)
	get struct (list)
	get body (list)

get headers -> EL
	each with state
	HEADER -> notify
	get in reverse order (newest first)?

notifications on ...?
	N, A, M, E with recursive flag

Index watches M+ (recursive)
Pager watches E
Sidebar N+

Events NEW, CHANGED, DELETED

Do objects need an IWatchable interface?
	tough for the N object (not refcounted)

backends:
	imap, pop, maildir(mh), mbox(mmdf), nntp, notmuch, compressed

ctx->data: pop, nntp, imap, mh, nm,
hdr->data: nntp, nm, imap, pop (idstr)

1 empty A per M if no <account>

struct naming?
	VMailbox (view)
	LAccount (list)

abstract the mailbox?
	add/remove()
	find_by_id()
	find_by_path()
	keep count
	mbox -> array for views?

slab allocator / factory ∀ myriad small objects?

unify all private data {new,free,init,get}_X

multiple notifications: let the receivers know what's coming
	start(uniq id, expected count)
	count * notify()
	end(uniq id)
	receivers can ignore some as long as they listen for `end`

drop mailbox_free()?
	use mbox_close

create header_free() ∀ mailboxes

should we steal account-hook <set> commands NO
	POSSIBLY -- if we have a *named* account
	and a matching hook

∀ backend, mailboxes - no info existing M, existing A?

imap <mailboxes> imaps://apple.com/aardvark -> M
     <mailboxes> imaps://apple.com/beaver

empty new M, open -> new A done
$folder + <mb> - path -> dummy A, no name, no type
match -> attach, not -> create & attach
A has no config for backwards compat
<a><mb> apple banana -> 2*M -> A
A is incomplete, but has config
	set user,pass -> A
adding to A -> need sibling test?
how would that work for maildir?  can't NO
open M, have A has type,config, still run A-hook

open A

how do we list all of M?
0 named A -> iterate through ML as <mb>'d
1+ named A -> <a> used -> assume always
	iterate through AL, then ML

sb_sort = A:alpha,M:new,M:alpha
if A: missing, don't display -> only M? complicated
if A: missing, don't sort A at all
sb_display_account [LIST] of A

maildir: <mb> a b c (no A specified) use dummy?
open 'b' don't need A, so continue using dummy
dummy means *AL*, ML, always

maildir <a><mb> a b c  named A, grouped config
only create dummy when needed?
	simple case only 1 A
sb_display = A1,A2,A3
	empty => all
	+=, -=
	!= (toggle?)
no advantage to displaying nothing!
	turn off sidebar

nm A matched by db path - contents of A just <mb>
nntp A matched by user,pass,host -- all subscribed groups
nm - param to name query? -> desc or
	<sb-subscribe>
	<sb-desc-folder> / <sb-name-folder>
		to make it session-permanent

mailbox_free -> separation between close and free?
	needed?
close -> maybe a reopen
free -> DEAD forever

open on Imap A -> LSUB & <mb>

A types:
	MboxA - name, config, data (->conn)
	ConnA - user, pass, port, host, etc
	(cfg)A - config

Imap -> Connection (stacked), Mbox, Nntp too
maildir -> NULL, compresse too
notmuch -> db info

how much M->data can become A->data?
	A-data
	M-data
	E-data
data-free will close connections if nec

hcache is opened at parse time -- how long is it kept open?
keep as A-data, keep open? YES

change mh_data() to get_mh_data() -- so it isn't mistaken as a cast

E-data
	pop: uid
	nntp: article num
	imap: flags, uid
	nm: uid
	md: none (flags?)
	mbox: none
	comp: none

mxapi: create compare function which uses backend-specific id

check POP uid in hcache, refno too (meaning?)

mx_open(imap://) (no folder info)
find A -> need backends to do matching
take host, user, port ito account (net backends)
take dir into account (maildir)
	no A for md -> base dir of '/'

split up mxops into A, M, E versions
A:
	path*
	mbox_open*
	msg_padding
M:
	msg_open*
	mbox_check/sync/close
E:
	tags*? or M?
	msg_commit
	msg_close

do all X ops really want to happen on parent(X)?
	so that... what?
	notifications?
	client shouldn't know/care

M might cache tags on E
	but that knowledge should be private to backend
E has ptr to M
	*it* should do *that* work
close() on X, open on parent(X)?
	is this the exception?

who probes the first path?
	we don't have an A
have NULL A ∀ backends?
	A(NULL)->probe(path)
if probe isn't in mxapi, who has list of probes?
	does probe return an A?
		no, not enough info

how do the backends get access to Config?
	don't want to use a global
	need main Config ptr to create A-specific Config

------------------------------------------------------------

who owns AL?

int mx_mbox_open(M, flags);
	M partially filled Mailbox, requirements are backend-specific

int mx_mbox_open(AL, M, flags);
	backend doesn't need to keep any objects
	or need access to any globals (except its own)

------------------------------------------------------------

mailboxes a b c
	a,b siblings, c different
	create dummy A0
	create one M per path
		probe path to get TYPE
		attach to dummy A0

open M(b)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? NO
	find matching A: FAILED
	open A
		create A1 (unnamed, no config)
		connect to server
		populate A1
	populate M (using A1)

open M(a)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? NO
	find matching A: MATCHED - A1
		using user,pass,host,port
	populate M (using A1)

open M(c)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? NO
	find matching A: FAILED
	open A
		create A2 (unnamed, no config)
		connect to server
		populate A2
	populate M (using A2)

------------------------------------------------------------

account apple
mailboxes a1 a2 a3
	create ML with A=apple

open M(a1)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? YES
	is open? NO
	open A
		create A1 (unnamed, no config)
		connect to server
		populate A1
	populate M (using A1)

open M(a2)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? YES
	is open? YES
	populate M (using A1)

mbox check_all should happen at A-level (for efficiency)

config: use synonyms and inheritance for A:user -> imap_user mapping?

--------------------------------------------------------------------------------

parse_mailboxes

nm_path_probe, nm_normalize_uri
mutt_expand_path(_regex)
imap_path_probe
	imap_expand_path
	imap_parse_path
	imap_conn_find
	mutt_conn_find
	mutt_account_hook
mx_path_canon (^-expansion)
	mx_path_probe -> path_canon
nm_path_probe
mx_path_probe
mx_path_probe

--------------------------------------------------------------------------------

mailboxes + folder -> Mailbox
	expand using $folder, $HOME
	if expansion fails, mailbox is errored and dropped
	backend may use "user", "login", "pass"
DON'T search for A, or attach an A
=> Mailbox (partial)
NO user, login, pass info lost => NEED A
=> find_A with partial info
reason for Username, ImapUser checks (account_match)

imap://user:pass@host:port/path

when matching mailboxes should search in reverse order
(most recently defined matching mailbox wins)

store login, user, pass on A, give ptr to Connection (shorter-lived)

auto A mailboxes:
	imap: LSUB subscribed
	nntp: newsrc
	maildir: how? flat search, or recursive option?
	notmuch: how? saved/pre-defined queries - how to we get them?

--------------------------------------------------------------------------------

mailboxes +name

expand using $folder, $HOME (or die) => Mailbox (partial)
find_A(M) or mx_find_A(M) -> mx_new_A(M?)
	flag for new?  when else will we need a new A?
new_A creates A and adata - need new for *name* of A
backends might have different Config overrides

--------------------------------------------------------------------------------

Mailboxes - new uses for path, realpath
	rename realpath to canon_path - contents BE-specific
if !A then path = canon_path, except for compressed
if A, then canon_path is canonical and path is pretty
	relaive to A-$folder (except compressed)
Internally convert =folder to +folder?
A_find_M(path) uses global AL (for now)

Does imap canon path contain user,pass,login,port?
	if there's a specific imap_find(), then no (only if A)
	what do we display to the user?
	what if two M differ only by user?

Account syntax?  A-name +folder - apple:+folder
	should *this* be shared in path?  ON
	if folder is in root of A-apple, then apple:folder is ok
	":+folder" relative to current M/A, equiv to "+folder"

canon path - "user" always, "pass" never, "login" if set, "port" if non-standard
	A-$folder set to /a/b or imap://a/b - stored as what?
	login info stored in A->data.conn
	$folder stored in A->config
		accept /a/b store as imap://a/b

expandos for canon_path, pretty_path, A-name too
	short_canon too? no (user,login,port) or make canon expando smart?
	when creating a new A, check others to determine which attributes
		make a path canonical (user,login,port) -- NO confusing
	
Mailbox/mbox path = user entered path, tidied up
	canon_path = realpath() of path

pop/nntp like imap
notmuch - path nm://query
	realpath include db path

WON'T be a !A (it'll always be present) only an UNNAMED A

--------------------------------------------------------------------------------

mailboxes X
	(relative|canon)
	A(exists|missing)
	account cmd?

1)
	canon(X)
	probe(X) => magic, ops

2)
	if (A.cmd) use A
	if (BE->find_A(X)) use A
	else BE->create_A(NULL)

3)
	BE->find(A,X) -> M
		error exists
	else BE->create_M(X) -> success
	ac_add(A,M)

mx functions?
	account_find(path)
	mbox_create(path)
	ac_add(A,M)
	ac_remove(A,M)

ac_function - names clash with Config
ac functions above mbox functions in API

"account apple" - don't know typ until "mailboxes"
if current A, close existing?  NO
or have mx_ac_free(A)? NO

account_create(name) -> A(empty)

--------------------------------------------------------------------------------

mbox_create(path, canon, magic)
	set magic, path, realpath

ac_create(name) set name, init config (no name => set neither)
ac_create(path) NO, ac_add(M) instead

ac_add(A,M) -> A check/set type, add M, link objs
ac_remove(A,M) -> unlink, remove M
ac_find(A, path) ∀ M do BE-specific M-compare(M, path)

who add A to BE list?  when?
	ac_add(A,M)?

does BE need a private list?
	not to start with

