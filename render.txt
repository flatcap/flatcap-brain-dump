librender

how to markup a line of text?
what about wrapped lines?

sidebar - lots of short lines
all applicable colours applied
lowest priority first
	NORMAL, ORDINARY, ... FLAGGED, OPEN, HIGHLIGHT

ColourText object accumulating stuff
/colour or /render library independent of neomutt
curses can render a CT object
CT knows how to merge colours/attrs
	fg overwrites fg
	bg overwrites bg
	attrs accumulate

e.g.
	"  ", Colour*, "boxname"
	CT 1 string, "  boxname"
	   1 ColourOffset { Colour, size_t, size_t }
	
Pager text - reading from file
	encoded, e.g. quoted printable
	"~~~~~<Cr>~~~~~"
How much text is cached as we process?
Where are the regexes anchored?
	Beginning of line?
	Start of body?
Is entire body in memory?  Probably
Parse into list of Segment pointers
Seg { startptr, len, colour }
Special Segs for <CR> (might not match screen)
Array of Line's
Recalc on SIGWINCH
Line is a collection of Segs or
Line is { num, seg idx, seg idx }
Easy to page up/down

When matching colour regex against line
match earliest, then greediest? OR
match 1 by 1 ∀ matches, even if they overlap

create regex shortcut '\s'
expand to [ \t\f\r\n]
see if it can match across line boundaries

Does mutt have a vim-like breakat option?
Which options should we mirror?

Raw text contains very long link
Quoted printable email
when email is rendered, current page only shows end of link

Decoded into memory
contains hard CRs
Regex whitespace munged
One Seg created ∀ text
∀ regex match against decoded
∀ match split Seg insert Colour

Apply line splitting according to wrapping rules
Insert <CR> or "+" etc as necessary

∀ Line call DisplayLine()

One regex has URI attr
Even though split each Seg knows complete URI

DisplayLine knows colours, attrs, text

Which layers do which splitting?
Is pager given encoded or decoded text?
	decoded

How much rendering is Neo-independent?
temp file is *decoded*
weeding is done before
toggle weeding -> recreate tmp file close/open pager

email headers - who does the foldeing to fit on screen?
How many Segs will be needed for 1 char wide screen?
are headers wrapped independently of text?
have min width of 10, or 20, chars?
to match regexes, headers need unwrapping
rendering header, respect "ignore" & hide some

librender - store colours/attrs/highlighting
parse colourscheme file
create markup objs using text, regexes, colours, attrs flags, width
not flags, config
	wrap width, smartwrap, breakat, linebreak, showbreak

too complicated?  break up

text + regex + colour -- apply_regex_colour()
	creates lots of Segs
line_split(text, options) -> more Segs
What about headers?

line breaks need finding, but not printing
resizing window doesn't regenerate tmp file

weeded headers could be present but not shown
same mechanism could be used for folding and <toggle-quoted>?
	hide signature?

flag the nature of each line:
	text, header, signature, quote, quote1,2,3.., PGP header
	search match, mime headers, weed header

after initial parsing call out to plugin parsers, e.g.
	.signature identifier
	markdown highlighter
	diff highlighter
implement as .so's with a simple API

plugins might want to define new highlight names, e.g.
	markdown_header1
we should accept some unknown names, or let plugin define them

if plugin defines colour items, then colour scheme would *have*
to be loaded after the plugin.  after config.  tricky
or give the plugins a class of names for colour items
	P_*
	P_MarkdownHeader1

plugin might suggest that a line shouldn't be wrapped (e.g. diff)

