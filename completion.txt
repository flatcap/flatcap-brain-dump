Auto-Completion API

Encapsulate all the completion code to make it easier to test and maintain.

- Create an Auto-Completion library -- separate the code from the rest of NeoMutt
- Create an API (list of functions) that everyone uses

This library should be only be dependent on libmutt.

The auto-completion code is given:
- a list of possible symbols to match
- what the user has typed so far

It replies by:
- doing nothing (no matches)
- completing the symbols (one match found)
- returning the list of matching symbols
  The user can either <kbd>Tab</kbd> through them or select from a menu

Currently, this code is scattered throughout NeoMutt and often uses global
variables.  It needs to be separated and tidied up.

--------------------------------------------------------------------------------

create, populate, query, destroy

query flags: ignore case, fuzzy, magic (dash==underscore), regex (~=fuzzy?), partial

pass list[] { flags, string }
need work buffer (matching length of longest string)
need cursor position
complete *over* flag
	abc|de<tab> -> abcdef|

option to match first, then cycle
match longest
	client responsibility

highlighting of matches for fuzzy/partial

flag partial: (anywhere in string)
	anchor: start, none, end

multi-field matching?  e.g. Index
pass [] { flags, str1, str2, etc }

flags control which are matched?  flags âˆ€ strings?
C.add_column(flags, [], num)
	have [] of flags for matches
	doesn't add data, just flags behaviour
C.add_row() probably better
	for data

need set of matcher callback functions
	pass flags, row

string data passed in is const

self-contained, except for libmutt
build and test in test-library repo branch

has a static vars (init.c)
	#define NUMVARS mutt_array_size(MuttVars)
	#define NUMCOMMANDS mutt_array_size(Commands)

	/* Initial string that starts completion. No telling how much the user has
	* typed so far. Allocate 1024 just to be sure! */
	static char UserTyped[1024] = { 0 };

	static int NumMatched = 0;          /* Number of matches for completion */
	static char Completed[256] = { 0 }; /* completed string (command or variable) */
	static const char **Matches;
	/* this is a lie until mutt_init runs: */
	static int MatchesListsize = MAX(NUMVARS, NUMCOMMANDS) + 10;

	#ifdef USE_NOTMUCH
	/* List of tags found in last call to mutt_nm_query_complete(). */
	static char **nm_tags;
	#endif

encapsulate & refactor
	sort variables, etc before auto-completion
		or properly sort the sources of the strings

