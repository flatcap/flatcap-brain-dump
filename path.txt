path_pretty()
	order for evaluation?
	run path_canon() first

consider
	folder for +
	home for ~

tidy paths for ???

mailbox backends don't know about $folder
shorten by +, ~, what else?

canon. expand prefix ∀?

separate path from mbox?  YES
	where? when?

canon
	expand
	local path vs canon mailbox

path:
	expand ~ (need $HOME)
	tidy dots

mbox:
	expand leading 'magic' chars
	get type
	need $folder
	delegate to mxapi

folder expansion *needs* to be done my mbox backend
	need to identify magic of $folder first

if [^-!<>@] subst, LOOP
if [+=] identify $folder, delegate to mxapi, END
if [~] subst $HOME, END
else relative?

tidy
	~/ or ~X/
	/ or other

check: are mutt_path_dirname() and mutt_path_parent() identical?

[☥] all the neomutt magic folder abbreviations
	[^-!<>@+=~]

canon(X) full path
	~/path
	relpath
	untidy path
	full mbox
	+mbox
	untidy mbox
	[☥] -> expand tidy

pretty(x)
	full path
	~/path
	relpath
	untidy
	full mbox
	+mbox
	untidy mbox
	[☥]?

1) canon
2) $folder
3) ~/

path_abbrev_folder
path_parent
str_inline_replace
mx_path_{probe,canon,pretty,parent}

when do M->path, M->realpath differ?
	M->realpath is realpat()d (symlinks followed)

replace realpath() with mutt_realpath()

add realpath param to mailbox_new()
	since we already know it

fs.path = absolute
fs.realpath = real path (no symlinks)

rename realpath to canon?

imap.path = full imap://...
imap.realpath = imap://user:port/...

notmuch.path = full notmuch://?query
notmuch.realpath = notmuch://path/to/db?query

when is $folder removed?
what if $folder includes user:port or db path?

canon: Leading magic chars
	+          Folder
	^          CurrentFolder
	-          LastFolder
	!!         LastFolder
	<          Record
	>          Mbox
	!          Spoolfile
	@user      save-hook path for user
	=          Folder
	~/         HomeDir
	~user/     user's Home dir
	/full/path Absolute path
	rel/path   Relative path

mx_pretty(path, folder)
	probe(path) -> type
	if mxapi.pretty delegte
		maildir, etc, tidy path (tilde)
		imap tidy *sub*path
		notmuch -> NULL?

--------------------------------------------------------------------------------

any function using an M needs to resolve paths themselves
distinguish "folders" / "mailboxes" that *must* be local files/dirs
add flag to canonical Mailboxes
create/delete/rename M available in index
	(pager too if any M functions are available)
		can't find any
delete/rename work on current M
	create prompts with current $folder!
should they be sidebar functions?
	or both?

--------------------------------------------------------------------------------

Path resolver - Buffer + flags
	char[] would be easier
States:
	unknown
	+pretty
	resolved
	canonical
	(r, c have magic)
resolve() p->r -- neo function, need $folder
pretty() r->p  -- neo function, need $folder
resolve needs to *tidy*?
	but not canonicalise
	collapse paths, but not symlinks?
	NO leave path as user intended?
	(use canon for comparison)
canon() r->c -- backend function
*flags* for state (U|P|R|C)
*flags* for local/remove/virtual?
How do we:
	u->p
	u->r
when do we probe?
	part of resolve?
	YES.  need to probe before we can tidy()
flag for URI format path!
	like 'stat' flag

--------------------------------------------------------------------------------

change folder - free form string
Path { "freeform", NULL, UNKNOWN }
resolve '+' etc, probe tidy
Path { "tidy", NULL, TYPE }
find_M needs canon for path_compare
	who does 'canon'? compare
find_M -> ∀A, ∀M compare(M.path, test.path)
find_M (a maibox function) doesn't need to know about canon
compare (a path function) canons both paths as necessary
does the +pretty name belong in Path? NO $folder may change
does the "desc name" belong in Path? Possibly.  use in browser, etc
separate path API from MXAPI?  can local M's share path functions?

path/mailbox types
	18 PATH
	6 MAILBOX
Path
	user -> tidied  ../ etc
	canon -> resolve symlinks
		use during config parting (for loop detection)
Distinguish between: FILE, DIR, EITHER?
	MUST_EXIST flag?
	WILL_CREATE flag?
Pretty(P) -> ~/ on user path
fopen(P) => P cannot contain '~'
Allow/disallow relative paths?
	or always expand?
P of ../dir can't canonicalise it '.' might change
resolve(P) turns relative path into absolute path
	resolve is a Mailbox thing
want a Path specifiy tidy?
	what about P/M vas?
	NO probe and use mxapi tidy
upstream resolve doesn't expand symlinks
	or do realpath (in pretty)
path *type* (with Mailbox flag)
	type, flags live in libcore
type is away of mxapi
	or plain PATH type is only path aware
mailbox type is mxapi-aware, can delegate to PATH type
PATH could delegate to STRING?
Config - what does "get" offer?  "user" or "canon" string?
	USER string, if we want canon, then get_native object
PATH needs global HomeDir (will probably end up in N.user_info)
set_path(P), path_tidy(P)
	or set user to anything, absolute, relative, ~/, then resolve on fopen?
	canon is useless
only tidy if absolute or ~/ (can then be canonicalised if necessary)
	means attach_save_dir "./" is OK
set mailbox(M) - probe, if "local" type delegate to PATH
	resolve, probe, tidy

Path { orig, canon, tidy, flags }

DT_PATH test
	file | dir
	absolute | relative | tilde
	clean | dirty (dir/..)
	symlink | real
	trailing slash | none

store as (abs|rel|tilde)
	tidy abs dirty
	expand for use?  NO
or expand before save?  BEFORE

expand before => fopen(C_X) will succeed without processing C_X

investigate nntp_expand_path

does struct Path need void *data for parsed URI info?

rename path2 wrappers to imap_* for debugging purposes

when to we canon +trash?
	just before use?
	or dup, then canon?  probably

maildir canon
	strip ",flags" from path, or ":"?

path always open with "orig", compare with "canon"
